// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
using System;
using System.Data;
using System.IO;

namespace SQLCheck
{

    //
    // Written by the Microsoft CSS SQL Networking Team
    //
    // This takes the DataSet generated by the Collectors methods and produces a text report
    // that is output to the TextWriter.
    //
    // In the current version of the application, the TextWriter outputs to the Console window and can be piped to a text file.
    //
    // TODO - re-order the report into three main sections: Computer, Client Drivers, SQL Services
    //


    public class TextReport  // the general rule is each method ends by outputting a blank line if it outputs any data
    {
        public static void Report(DataSet ds, TextWriter s)
        {
            int fieldWidth = 160;

            s.WriteLine(SmartString.CenterText("Start of Report", fieldWidth));  // 160 characters width and 1 space before and after
            s.WriteLine();
            ReportHeading(ds, s);
            s.WriteLine();
            s.WriteLine(SmartString.CenterText("Computer Information", fieldWidth));
            s.WriteLine();
            ReportComputer(ds, s);
            ReportDiskDrive(ds, s);
            ReportNetwork(ds, s);
            s.WriteLine();
            s.WriteLine(SmartString.CenterText("Client Security and Driver Information", fieldWidth));
            s.WriteLine();
            ReportSecurity(ds, s);
            ReportDatabaseDriver(ds, s);
            s.WriteLine();
            s.WriteLine(SmartString.CenterText("SQL Server Information", fieldWidth));
            s.WriteLine();
            ReportCertificate(ds, s);
            ReportService(ds, s);
            ReportSQLServer(ds, s);
            ReportFooter(s);
            s.WriteLine(SmartString.CenterText("End of Report", fieldWidth));
        }

        static void ReportHeading(DataSet ds, TextWriter s)
        {
            DataRow Computer = ds.Tables["Computer"].Rows[0];
            s.WriteLine($"SQL Server Connectivity Check v{Program.version}, run on {DateTime.Now.ToString(@"MM/dd/yyyy hh:mm:ss tt")}");
            s.WriteLine("by the Microsoft CSS SQL Networking Team");
            s.WriteLine();
            s.WriteLine("This report contains the following sections:");
            s.WriteLine("1. Computer, Domain, Disk Space, Network Adapters.");
            s.WriteLine("2. Client Drivers, SQL Aliases, and Local Security for client connectivity.");
            s.WriteLine("3. SQL Server Processes of Interest, Service Account Properties, Service Principal Names, SPN Issues, and Suggested SPNs.");
            s.WriteLine();
            //
            // add later if we save to a DataSet on disk
            //
            //s.WriteLine($"Schema version: {Program.schemaVersion}");
            //s.WriteLine();
        }

        static void ReportFooter(TextWriter s)
        {
            // s.WriteLine("End of Report");
            //
            // Add later when the project is on GitHub
            //
            //s.WriteLine();
            //s.WriteLine("Please send your feedback to our Wiki at https://github.com/microsoft/CSS_SQL_Networking_Tools/wiki.");
        }

        static void ReportComputer(DataSet ds, TextWriter s)  // outputs computer and domain information
        {
            DataRow Computer = ds.Tables["Computer"].Rows[0];
            DataRow Domain = null;
            bool is64bit = Computer.GetBoolean("CPU64Bit");

            s.WriteLine($"Report run by:              {Computer.GetString("CurrentUser")}");
            s.WriteLine();
            s.WriteLine($"NETBIOS Name:               {Computer.GetString("NETBIOSName")}");       // use of extension methods in case a field does not exist
            s.WriteLine($"FQDN:                       {Computer.GetString("FQDN")}");
            s.WriteLine($"DNS Suffix:                 {Computer.GetString("DNSSuffix")}");
            s.WriteLine();
            s.WriteLine($"Windows Name and Edition:   {Computer.GetString("WindowsName")}");
            s.WriteLine($"Windows Version:            {Computer.GetString("WindowsVersion")}");
            s.WriteLine($"Windows Build:              {Computer.GetString("WindowsBuild")}");
            s.WriteLine($"Windows Release ID:         {Computer.GetString("WindowsReleaseID")}");
            s.WriteLine($"64-Bit System:              {Computer.GetString("CPU64Bit")}");
            s.WriteLine($".NET 4.x version:           {Computer.GetString("CLR4Version")}");
            s.WriteLine($"CLR 4.0 Strong Crypto:      {Computer.GetString("CLR4StrongCrypto")}");
            if (Computer.GetBoolean("CPU64Bit"))
            {
                s.WriteLine($"CLR 4.0 Strong Crypto x86:  {Computer.GetString("CLR4StrongCryptoX86")}");
            }
            s.WriteLine($".NET 2.x/3.x version:       {Computer.GetString("CLR2Version")}");
            s.WriteLine($"CLR 2.0 Strong Crypto:      {Computer.GetString("CLR2StrongCrypto")}");
            if (Computer.GetBoolean("CPU64Bit"))
            {
                s.WriteLine($"CLR 2.0 Strong Crypto x86:  {Computer.GetString("CLR2StrongCryptoX86")}");
            }
            s.WriteLine($"Clustered:                  {Computer.GetBoolean("Clustered")}");
            s.WriteLine($"IIS Running:                {Computer.GetBoolean("IISRunning")}");
            s.WriteLine($"CredentialGuard enabled:    {Computer.GetBoolean("CredentialGuard")}");
            s.WriteLine();

            if (Computer.IsNull("LastSystemReboot"))
            {
                s.WriteLine($"Last System Reboot:");  // clintonw 9/8/2022
            }
            else 
            {
                DateTime dt = (DateTime)(Computer["LastSystemReboot"]);
                s.WriteLine($"Last System Reboot:         {Computer.GetString("LastSystemReboot")} (Uptime: {Utility.FormatInterval(DateTime.Now - dt)})");  // clintonw 9/8/2022
            }
            
            s.WriteLine($"Reboot Recommended:         {Computer.GetBoolean("RebootNeeded")}");
            s.WriteLine();
            s.WriteLine($"Computer Role:              {Computer.GetString("ComputerRole")}");
            s.WriteLine($"Domain/Workgroup:           {Computer.GetString("DomainOrWorkgroupName")}");
            s.WriteLine($"Joined to Domain:           {Computer.GetString("JoinedToDomain")}");
            s.WriteLine($"Connected to Domain:        {Computer.GetString("ConnectedToDomain")}");
            s.WriteLine($"Expanded Domain Name:       {Computer.GetString("ExpandedName")}");       // Domain name expanded: DC=CONTOSO,DC=COM
            s.WriteLine();

            if (Computer.GetBoolean("JoinedToDomain") && ds.Tables["Domain"].Rows.Count == 1)
            {
                Domain = ds.Tables["Domain"].Rows[0];
                s.WriteLine($"Domain Name:                {Domain.GetString("DomainName")} ({Domain.GetString("DomainShortName")})");
                s.WriteLine($"Domain Mode:                {Domain.GetString("DomainMode")}");
                s.WriteLine($"Parent Domain:              {Domain.GetString("ParentDomain")}");
                s.WriteLine($"Root Domain:                {Domain.GetString("RootDomain")}");
                s.WriteLine($"Forest Domain:              {Domain.GetString("ForestName")}");
                s.WriteLine($"Forest Mode:                {Domain.GetString("ForestMode")}");
                s.WriteLine();

                // domains trusted by this domain
                if (ds.Tables["RelatedDomain"].Rows.Count == 0)
                {
                    s.WriteLine("There do not appear to be any other domains in this organization.");
                }
                else
                {
                    s.WriteLine($"Domains trusted by {Domain.GetString("DomainName")}.");
                    s.WriteLine();
                    DataTable dtRelatedDomain = ds.Tables["RelatedDomain"];
                    ReportFormatter rf = new ReportFormatter();
                    rf.SetColumnNames("Target Domain:L","Trust Type:L", "Direction:L", "Selective Auth:L", "Encryption:L", "Attributes:L", "Message:L");
                    DataView dvRelatedDomains = new DataView(dtRelatedDomain);
                    dvRelatedDomains.Sort = "TargetDomain";
                    foreach (DataRowView RelatedDomain in dvRelatedDomains)
                    {
                        rf.SetcolumnData(RelatedDomain.GetString("TargetDomain"),
                                         RelatedDomain.GetString("TrustType"),
                                         RelatedDomain.GetString("TrustDirection"),
                                         RelatedDomain.GetBoolean("SelectiveAuthentication").ToString(),
                                         RelatedDomain.GetString("SupportedEncryptionTypes"),
                                         RelatedDomain.GetString("TrustAttributes"),
                                         RelatedDomain.GetString("Message"));
                    }
                    s.WriteLine(rf.GetHeaderText());
                    s.WriteLine(rf.GetSeparatorText());
                    for (int i = 0; i < rf.GetRowCount(); i++)
                    {
                        s.WriteLine(rf.GetDataText(i));
                    }
                }
                s.WriteLine();

                // domains trusted by the root domain
                if (ds.Tables["RootDomainRelatedDomain"].Rows.Count == 0)
                {
                    s.WriteLine($"There do not appear to be any domains trusted by root domain {Domain.GetString("RootDomain")}.");
                }
                else
                {
                    s.WriteLine($"Domains trusted by root domain {Domain.GetString("RootDomain")}.");
                    s.WriteLine();
                    DataTable dtRelatedDomain = ds.Tables["RootDomainRelatedDomain"];
                    ReportFormatter rf = new ReportFormatter();
                    rf.SetColumnNames("Target Domain:L", "Trust Type:L", "Direction:L", "Selective Auth:L", "Encryption:L", "Attributes:L", "Message:L");
                    DataView dvRelatedDomains = new DataView(dtRelatedDomain);
                    dvRelatedDomains.Sort = "TargetDomain";
                    foreach (DataRowView RelatedDomain in dvRelatedDomains)
                    {
                        rf.SetcolumnData(RelatedDomain.GetString("TargetDomain"),
                                         RelatedDomain.GetString("TrustType"),
                                         RelatedDomain.GetString("TrustDirection"),
                                         RelatedDomain.GetBoolean("SelectiveAuthentication").ToString(),
                                         RelatedDomain.GetString("SupportedEncryptionTypes"),
                                         RelatedDomain.GetString("TrustAttributes"),
                                         RelatedDomain.GetString("Message"));
                    }
                    s.WriteLine(rf.GetHeaderText());
                    s.WriteLine(rf.GetSeparatorText());
                    for (int i = 0; i < rf.GetRowCount(); i++)
                    {
                        s.WriteLine(rf.GetDataText(i));
                    }
                }
                s.WriteLine();

                // domains trusted by the forest
                if (ds.Tables["ForestRelatedDomain"].Rows.Count == 0)
                {
                    s.WriteLine($"There do not appear to be any domains trusted by forest {Domain.GetString("ForestName")}.");
                }
                else
                {
                    s.WriteLine($"Forests trusted by root domain {Domain.GetString("ForestName")}.");
                    s.WriteLine();
                    DataTable dtRelatedDomain = ds.Tables["ForestRelatedDomain"];
                    ReportFormatter rf = new ReportFormatter();
                    rf.SetColumnNames("Target Forest:L", "Trust Type:L", "Direction:L", "Selective Auth:L", "Encryption:L", "Attributes:L", "Message:L");
                    DataView dvRelatedDomains = new DataView(dtRelatedDomain);
                    dvRelatedDomains.Sort = "TargetDomain";
                    foreach (DataRowView RelatedDomain in dvRelatedDomains)
                    {
                        rf.SetcolumnData(RelatedDomain.GetString("TargetDomain"),
                                         RelatedDomain.GetString("TrustType"),
                                         RelatedDomain.GetString("TrustDirection"),
                                         RelatedDomain.GetBoolean("SelectiveAuthentication").ToString(),
                                         RelatedDomain.GetString("SupportedEncryptionTypes"),
                                         RelatedDomain.GetString("TrustAttributes"),
                                         RelatedDomain.GetString("Message"));
                    }
                    s.WriteLine(rf.GetHeaderText());
                    s.WriteLine(rf.GetSeparatorText());
                    for (int i = 0; i < rf.GetRowCount(); i++)
                    {
                        s.WriteLine(rf.GetDataText(i));
                    }
                }
                s.WriteLine();
            }

            s.WriteLine($"Program Files Folder:       {Computer.GetString("ProgramFilesFolder")}");
            s.WriteLine($"Common Files Folder:        {Computer.GetString("CommonFilesFolder")}");

            if (is64bit)
            {
                s.WriteLine($"Program Files (x86) Folder: {Computer.GetString("ProgramFilesx86Folder")}");
                s.WriteLine($"Common Files (x86) Folder:  {Computer.GetString("CommonFilesx86Folder")}");
            }
            s.WriteLine();

            // report messages in standard format
            ReportMessages(ds, s, "Computer", Computer.GetInteger("ID"));  // returns a blank line at the end
            if (Domain != null)
            {
                ReportMessages(ds, s, "Domain", Domain["ID"].ToInt());  // returns a blank line at the end
            }
        }

        static void ReportDiskDrive(DataSet ds, TextWriter s)  // outputs computer and domain information
        {
            DataTable dtDiskDrive = ds.Tables["DiskDrive"];
            ReportFormatter rf = new ReportFormatter();
            s.WriteLine("Disk Drives:");
            s.WriteLine();
            rf.SetColumnNames("Drive:L","Type:L", "Format:L", "Capacity:R", "Bytes Free:R", "% Free:R", "Status:L");
            foreach (DataRow DiskDrive in dtDiskDrive.Rows)
            {
                rf.SetcolumnData(DiskDrive.GetString("Drive"),
                                 DiskDrive.GetString("DriveType"),
                                 DiskDrive.GetString("DriveFormat"),
                                 DiskDrive.GetString("Capacity"),
                                 DiskDrive.GetString("BytesFree"),
                                 DiskDrive.GetString("PctFree"),
                                 DiskDrive.GetString("Message"));
            }
            s.WriteLine(rf.GetHeaderText());
            s.WriteLine(rf.GetSeparatorText());
            for (int i = 0; i < rf.GetRowCount(); i++)
            {
                s.WriteLine(rf.GetDataText(i));
            }
            s.WriteLine();
        }

        static void ReportNetwork(DataSet ds, TextWriter s)  // outputs network settings, IP addresses, DNS Aliases, hosts file entries, and NIC adapters
        {

            // global network settings

            DataTable dtNetwork = ds.Tables["Network"];
            DataTable dtNetworkAdapter = ds.Tables["NetworkAdapter"];
            DataTable dtHostAlias = ds.Tables["HostAlias"];
            DataTable dtHostsEntries = ds.Tables["HostsEntries"];
            DataTable dtIPAddress = ds.Tables["IPAddress"];
            DataTable dtFLTMC = ds.Tables["FLTMC"];

            s.WriteLine("Network Settings:");
            s.WriteLine();

            if (dtNetwork.Rows.Count > 0)
            {
                DataRow Network = dtNetwork.Rows[0];
                s.WriteLine($"TCPMaxDataRetransmissions:  {Network.GetString("TcpMaxDataRetransmissions")}");
                s.WriteLine($"Initial RTO:                {Network.GetString("InitialRTO")}");
                s.WriteLine($"Max SYN Retransmissions:    {Network.GetString("MaxSYNRetransmissions")}");
                s.WriteLine($"TCPChimney:                 {Network.GetString("EnableTCPChimney")}");
                s.WriteLine($"RSS:                        {Network.GetString("EnableRSS")}");
                s.WriteLine($"TCPA:                       {Network.GetString("EnableTCPA")}");
                s.WriteLine($"Min Ephemeral Port:         {Network.GetString("MinUserPort")}");
                s.WriteLine($"Max Ephemeral Port:         {Network.GetString("MaxUserPort")}");
                s.WriteLine($"TCP Timed Wait Delay:       {Network.GetString("TCPTimedWaitDelay")}");
                s.WriteLine($"Syn Attack Protect:         {Network.GetString("SynAttackProtect")}");
                s.WriteLine();
                ReportMessages(ds, s, "Network", Network["ID"].ToInt());  // returns a blank line at the end
            }

            // DNS Aliases - collector does not work 6/13/2022

            //if (dtHostAlias.Rows.Count == 0)
            //{
            //    s.WriteLine("No DNS aliases found for this machine.");
            //}
            //else
            //{
            //    s.WriteLine("The following DNS aliases found for this machine:");
            //    s.WriteLine();
            //    foreach (DataRow HostAlias in dtHostAlias.Rows)
            //    {
            //        s.WriteLine($"    {HostAlias.GetString("DNS_Alias")}");
            //    }
            //}
            //s.WriteLine();

            // Host file entries

            if (dtHostsEntries.Rows.Count == 0)
            {
                s.WriteLine("No HOSTS file entries found for this machine.");
            }
            else
            {
                s.WriteLine("The following HOSTS file entries were found for this machine:");
                s.WriteLine();
                foreach (DataRow HostsEntry in dtHostsEntries.Rows)
                {
                    s.WriteLine($"    {HostsEntry.GetString("HostsEntry")}");
                }
            }
            s.WriteLine();

            // IP Addresses

            ReportFormatter rf = new ReportFormatter();
            rf.SetColumnNames("Address Family:L", "Address:L");
            foreach (DataRow IPAddress in dtIPAddress.Rows)
            {
                rf.SetcolumnData(IPAddress.GetString("AddressFamily"), IPAddress.GetString("Address"));
            }
            s.WriteLine("The following IP addresses are associated with this machine:");
            s.WriteLine();
            s.WriteLine(rf.GetHeaderText());
            s.WriteLine(rf.GetSeparatorText());
            for (int i = 0; i < rf.GetRowCount(); i++) s.WriteLine(rf.GetDataText(i));
            s.WriteLine();

            // FLTMC Filters

            string filterNames = "", FltMCDelimiter = " | ";
            DataView dvFLTMC = new DataView(dtFLTMC);
            dvFLTMC.Sort = "Name";
            foreach (DataRowView FLTMC in dvFLTMC)
            {
                filterNames += FltMCDelimiter + FLTMC.GetString("Name");
            }
            filterNames = filterNames == "" ? "<none>" : filterNames.Substring(FltMCDelimiter.Length);   // trim the initial ' | ' ... 3 characters
            s.WriteLine($"FLTMC Filters: {filterNames}");
            s.WriteLine();

            // network mini drivers

            DataTable dtNetworkMiniDriver = ds.Tables["NetworkMiniDriver"];
            if (dtNetworkMiniDriver.Rows.Count == 0)
            {
                s.WriteLine("Network Mini-Drivers: none found");
                s.WriteLine();
            }
            else
            {
                s.WriteLine("Network Mini-Drivers:");
                s.WriteLine();

                rf = new ReportFormatter();
                rf.SetColumnNames("Service Name:L", "Filter Media Types:L", "Help Text:L");
                DataView dvNetworkMiniDriver = new DataView(dtNetworkMiniDriver);
                dvNetworkMiniDriver.Sort = "Service";
                foreach (DataRowView NetworkMiniDriver in dvNetworkMiniDriver)
                {
                    rf.SetcolumnData(NetworkMiniDriver.GetString("Service"),
                                     NetworkMiniDriver.GetString("FilterMediaTypes"),
                                     NetworkMiniDriver.GetString("HelpText"));
                }
                s.WriteLine(rf.GetHeaderText());
                s.WriteLine(rf.GetSeparatorText());
                for (int i = 0; i < rf.GetRowCount(); i++) s.WriteLine(rf.GetDataText(i));
                s.WriteLine();
            }


            // network adapters

            s.WriteLine("Network Adapters:");
            s.WriteLine();

            foreach (DataRow NetworkAdapter in dtNetworkAdapter.Select("", "Name"))  // .Select is alternate to DataView and Sort
            {
                s.WriteLine($"Name:                       {NetworkAdapter.GetString("Name")}");
                s.WriteLine($"Adapter Type:               {NetworkAdapter.GetString("AdapterType")}");
                s.WriteLine($"MAC Address:                {NetworkAdapter.GetString("MACAddress")}");
                s.WriteLine($"Driver Date:                {NetworkAdapter.GetString("DriverDate")}");
                s.WriteLine($"Speed:                      {NetworkAdapter.GetString("Speed")}");
                s.WriteLine($"Speed/Duplex:               {NetworkAdapter.GetString("SpeedDuplex")}");
                s.WriteLine($"Flow Control:               {NetworkAdapter.GetString("FlowControl")}");
                s.WriteLine($"RSS:                        {NetworkAdapter.GetString("RSS")}");
                s.WriteLine($"Jumbo Frames:               {NetworkAdapter.GetString("JumboPacket")}");
                s.WriteLine($"NIC Teaming:                {NetworkAdapter.GetBoolean("NICTeaming")}");
                s.WriteLine();
                ReportMessages(ds, s, "NetworkAdapter", NetworkAdapter["ID"].ToInt());  // returns a blank line at the end
            }
        }

        static void ReportSecurity(DataSet ds, TextWriter s)  // outputs computer and domain information
        {
            DataRow Computer = ds.Tables["Computer"].Rows[0];
            DataRow Security = ds.Tables["Security"].Rows[0];
            s.WriteLine("Security Settings:");
            s.WriteLine();
            s.WriteLine($"Crash on Audit Fail:        {Security.GetString("CrashOnAuditFail")}");
            s.WriteLine($"Lanman Compatibility Level: {Security.GetString("lanmanCompatibilityLevel")}");
            s.WriteLine($"Disable Loopback Check:     {Security.GetString("DisableLoopbackCheck")}");
            s.WriteLine($"Back Connection Host Names: {Security.GetString("BackConnectionHostNames")}");
            s.WriteLine($"Max Kerberos Token Size:    {Security.GetString("MaxTokenSize")}");
            s.WriteLine($"Kerberos Logging Level:     {Security.GetString("KerberosLogLevel")}");
            s.WriteLine($"Kerberos local Encryption:  {Security.GetString("KerberosLocalEncryption")}");
            s.WriteLine();
            ReportMessages(ds, s, "Security", Security["ID"].ToInt());  // returns a blank line at the end

            // TLS Settings

            DataTable dtTLS = ds.Tables["TLS"];
            ReportFormatter rf = new ReportFormatter();
            // rf.SetColumnNames("Client/Server:L", "TLS Version:L", "Setting:L", "Default:L", "Registry:L", "Policy:L");  // we don't collect all these columns, yet
            rf.SetColumnNames("Client/Server:L", "TLS Version:L", "Default:L", "Enabled in Reg:L", "Disabled By Default:L", "Effective Value:L");
            foreach (DataRow TLS in dtTLS.Rows)
            {
                rf.SetcolumnData(TLS["ClientOrServer"].ToString(),
                                 TLS["TLSVersion"].ToString(),
                                 TLS.GetString("DefaultValue"),
                                 TLS.GetString("EnabledValue"),
                                 TLS.GetString("DisabledByDefaultValue"),
                                 TLS.GetString("EffectiveValue"));
            }
            s.WriteLine(rf.GetHeaderText());
            s.WriteLine(rf.GetSeparatorText());
            for (int i = 0; i < rf.GetRowCount(); i++) s.WriteLine(rf.GetDataText(i));
            s.WriteLine();
            ReportMessages(ds, s, "TLS", -1);  // returns a blank line at the end ... -1 = messages for all rows

            //
            // ProtocolOrder
            //

            DataTable dtProtocolOrder = ds.Tables["ProtocolOrder"]; // there should be exactly 1 row ... unless there was a problem
            if (dtProtocolOrder.Rows.Count == 1)
            {
                s.WriteLine("Cipher Suite Protocol Order:");
                s.WriteLine();
                DataRow ProtocolOrder = dtProtocolOrder.Rows[0];
                string registryCSV = ProtocolOrder.GetString("RegistryList");
                string policyCSV = ProtocolOrder.GetString("PolicyList");
                string[] registryList = registryCSV.Split(',');
                string[] policyList = policyCSV.Split(',');
                bool DHERisk = false;
                if (policyCSV != "")
                {
                    if (policyCSV.ToUpper().Contains("TLS_DHE_")) DHERisk = true;
                }
                else if (registryCSV != "")
                {
                    if (registryCSV.ToUpper().Contains("TLS_DHE_")) DHERisk = true;
                }
                rf = new ReportFormatter();
                rf.SetColumnNames("Registry List:L", "Policy List:L");
                for (int i = 0; i < Math.Max(registryList.Length, policyList.Length); i++)  // loop for the longest array
                {
                    rf.SetcolumnData(i < registryList.Length ? registryList[i] : "",
                                     i < policyList.Length ? policyList[i] : "");
                }
                s.WriteLine(rf.GetHeaderText());
                s.WriteLine(rf.GetSeparatorText());
                for (int i = 0; i < rf.GetRowCount(); i++) s.WriteLine(rf.GetDataText(i));
                s.WriteLine();
                s.WriteLine($"Diffie-Hellman algorithm version: {Computer.GetString("DiffieHellmanVersion")}");
                if (DHERisk)
                {
                    s.WriteLine("Diffie-Hellman cipher suites are enabled. Possible risk of intermittent TLS failures if the algorithm version is different between clients and servers.");
                }
                else
                {
                    s.WriteLine("Diffie-Hellman cipher suites are not enabled. This avoids the risk of certain intermittent TLS failures.");
                }
                s.WriteLine();
                // list all items in the Protocol list that aren't in the registry list
                ReportMessages(ds, s, "ProtocolOrder", -1);  // returns a blank line at the end ... -1 = messages for all rows
            }
        }

        static void ReportCertificate(DataSet ds, TextWriter s)  // outputs a list of the local computer MY store
        {
            DataTable dtCertificate = ds.Tables["Certificate"];

            s.WriteLine("Certificates in the Local Computer MY Store:");
            s.WriteLine();

            ReportFormatter rf = new ReportFormatter();
            rf.SetColumnNames("Friendly Name:L", "CN:L", "SAN:L", "Thumbprint:L", "Server Cert:L", "Key Len:R", "Sig Type:L", "KeySpec:L", "Usage:L", "Private Key:L", "Not Before:L", "Not After:L", "Problem:L");
            foreach (DataRow Certificate in dtCertificate.Rows)
            {
                rf.SetcolumnData(Certificate.GetString("FriendlyName"),
                                 Certificate.GetString("CommonName"),
                                 Certificate.GetString("SubjectAlternativeName"),
                                 Certificate.GetString("ThumbPrint"),
                                 Certificate.GetBoolean("ServerCert") ? "Yes" : "",
                                 Certificate.GetString("KeySize"),
                                 Certificate.GetString("SignatureAlgorithm"),
                                 Certificate.GetString("KeySpec"),
                                 Certificate.GetString("KeyUsage"),
                                 Certificate.GetBoolean("HasPrivateKey") ? "Yes" : "",
                                 Certificate.GetString("NotBefore"),
                                 Certificate.GetString("NotAfter"),
                                 Certificate.GetString("Message"));
            }
            s.WriteLine(rf.GetHeaderText());
            s.WriteLine(rf.GetSeparatorText());
            for (int i = 0; i < rf.GetRowCount(); i++) s.WriteLine(rf.GetDataText(i));
            s.WriteLine();
            ReportMessages(ds, s, "Certificate", -1);  // returns a blank line at the end ... -1 = messages for all rows
        }

        static void ReportService(DataSet ds, TextWriter s)  // outputs computer and domain information
        {
            DataRow Computer = ds.Tables["Computer"].Rows[0];
            DataTable dtService = ds.Tables["Service"];
            DataTable dtSPNAccount = ds.Tables["SPNAccount"];
            DataTable dtConstrainedDelegationSPN = ds.Tables["ConstrainedDelegationSPN"];
            DataTable dtSPN = ds.Tables["SPN"];

            // individual service details

            s.WriteLine("Services of Interest:");
            s.WriteLine();

            ReportFormatter rf = new ReportFormatter();
            rf.SetColumnNames("Name:L", "Instance:L", "Description:L", "PID:R", "Service Account:L", "Domain Account:L", "Start Mode:L", "Started:L", "Status:L");
            foreach (DataRow Service in dtService.Select("","Name"))
            {
                rf.SetcolumnData(Service.GetString("Name"),
                                 Service.GetString("Instance"),
                                 Service.GetString("Description"),
                                 Service.GetString("PID"),
                                 Service.GetString("ServiceAccount"),
                                 Service.GetString("DomainAccount"),
                                 Service.GetString("StartMode"),
                                 Service.GetBoolean("Started").ToString(),
                                 Service.GetString("Status"));
            }
            s.WriteLine(rf.GetHeaderText());
            s.WriteLine(rf.GetSeparatorText());
            for (int i = 0; i < rf.GetRowCount(); i++) s.WriteLine(rf.GetDataText(i));
            s.WriteLine();
            ReportMessages(ds, s, "Service", -1);  // returns a blank line at the end ... -1 = messages for all rows

            // Domain account properties

            s.WriteLine("Domain Service Account Properties:");
            s.WriteLine();
            rf = new ReportFormatter();
            rf.SetColumnNames("Account:L", "Domain:L", "Type:L", "UAC:R", "Sensitive:L", "Trust for Del.:L", "Const. Del.:L", "Kerberos Encryption:L");
            foreach (DataRow SPNAccount in dtSPNAccount.Rows)
            {
                rf.SetcolumnData(SPNAccount.GetString("Account"),
                                 SPNAccount.GetString("Domain"),
                                 SPNAccount.GetString("AccountType"),
                                 SPNAccount.GetString("UserAccountControl"),
                                 SPNAccount.GetBoolean("Sensitive").ToString(),
                                 SPNAccount.GetBoolean("TrustedForDelegation").ToString(),
                                 SPNAccount.GetBoolean("ConstrainedDelegationEnabled").ToString(),
                                 SPNAccount.GetString("KerberosEncryption"));
            }
            s.WriteLine(rf.GetHeaderText());
            s.WriteLine(rf.GetSeparatorText());
            for (int i = 0; i < rf.GetRowCount(); i++) s.WriteLine(rf.GetDataText(i));
            s.WriteLine();
            ReportMessages(ds, s, "SPNAccount", -1);  // returns a blank line at the end ... -1 = messages for all rows

            // Credential Guard -> Constrained Delegation

            if (Computer.GetBoolean("CredentialGuard"))
            {
                s.WriteLine("Warning: Credential Guard is enabled. Unconstrained delegation will not work.");
                s.WriteLine("");
            }
            else
            {
                s.WriteLine("Info: Credential Guard is not enabled. Unconstrained delegation should work.");
                s.WriteLine("");
            }

            // Constrained Delegation SPNs

            if (dtConstrainedDelegationSPN.Rows.Count == 0)
            {
                s.WriteLine("No constrained delegation back-end service SPNs were found on any of the above accounts.");
                s.WriteLine();
            }
            else
            {
                s.WriteLine("The following constrained delegation back-end service SPNs were found:");
                s.WriteLine();
                rf = new ReportFormatter();
                rf.SetColumnNames("Account:L", "SPN:L");
                foreach (DataRow ConstrainedDelegationSPN in dtConstrainedDelegationSPN.Select("","ServiceAccount,SPN"))
                {
                    rf.SetcolumnData(ConstrainedDelegationSPN.GetString("ServiceAccount"),
                                     ConstrainedDelegationSPN.GetString("SPN"));
                }
                s.WriteLine(rf.GetHeaderText());
                s.WriteLine(rf.GetSeparatorText());
                for (int i = 0; i < rf.GetRowCount(); i++) s.WriteLine(rf.GetDataText(i));
                s.WriteLine();
            }

            // SPNs on the above service accounts

            if (dtSPN.Rows.Count == 0)
            {
                s.WriteLine("No Service Principal Names were found on any of the above accounts.");
                s.WriteLine();
            }
            else
            {
                s.WriteLine("The following Service Principal Names were found:");
                s.WriteLine();
                rf = new ReportFormatter();
                rf.SetColumnNames("Account:L", "SPN:L", "Has Duplicates:L");
                foreach (DataRow SPN in dtSPN.Select("", "ServiceAccount,SPN"))
                {
                    rf.SetcolumnData(SPN.GetString("ServiceAccount"),
                                     SPN.GetString("SPN"),
                                     SPN.GetBoolean("HasDuplicates").ToString());
                }
                s.WriteLine(rf.GetHeaderText());
                s.WriteLine(rf.GetSeparatorText());
                for (int i = 0; i < rf.GetRowCount(); i++) s.WriteLine(rf.GetDataText(i));
                s.WriteLine();
                ReportMessages(ds, s, "SPN", -1);  // returns a blank line at the end ... -1 = messages for all rows
            }
        }

        static void ReportDatabaseDriver(DataSet ds, TextWriter s)  // outputs computer and domain information
        {
            s.WriteLine("SQL Server OLE DB Providers and ODBC Drivers:");
            s.WriteLine();

            //
            // ODBC messages
            //

            DataRow ODBC = ds.Tables["ODBC"].Rows[0];

            if (ODBC.GetString("ODBC_User_Trace") == "1" ||
                ODBC.GetString("ODBC_Machine_Trace") == "1" ||
                ODBC.GetString("ODBC_User_Trace_WOW") == "1" ||
                ODBC.GetString("ODBC_Machine_Trace_WOW") == "1")
            {
                s.WriteLine("ODBC traces are enabled. Data access performance can be negatively impacted.");
                if (ODBC.GetString("ODBC_User_Trace") == "1") s.WriteLine("ODBC User Trace:           True");
                if (ODBC.GetString("ODBC_Machine_Trace") == "1") s.WriteLine("ODBC System Trace:         True");
                if (ODBC.GetString("ODBC_User_Trace_WOW") == "1") s.WriteLine("32-bit ODBC User Trace:    True");
                if (ODBC.GetString("ODBC_Machine_Trace_WOW") == "1") s.WriteLine("32-bit ODBC System Trace:  True");
            }
            else
            {
                s.WriteLine("ODBC traces are disabled.");
            }
            s.WriteLine();

            //
            // List of installed drivers and Providers
            //

            DataTable dtDatabaseDriver = ds.Tables["DatabaseDriver"];
            ReportFormatter rf = new ReportFormatter();

            rf.SetColumnNames("Name:L", "Type:L", "Version:L", "Supported:L", "TLS 1.2:L", "TLS 1.3:L", "MSF:L", "GUID:L", "Path:L", "Message:L");
            foreach (DataRow DatabaseDriver in dtDatabaseDriver.Rows)
            {
                if (DatabaseDriver.GetString("Supported") != "")  // only SQL drivers and providers have this set
                {
                    rf.SetcolumnData(DatabaseDriver.GetString("DriverName"),
                                     DatabaseDriver.GetString("DriverType"),
                                     DatabaseDriver.GetString("Version"),
                                     DatabaseDriver.GetString("Supported"),
                                     DatabaseDriver.GetString("TLS12"),
                                     DatabaseDriver.GetString("TLS13"),
                                     DatabaseDriver.GetString("MultiSubnetFailoverSupport"),
                                     DatabaseDriver.GetString("Guid"),
                                     DatabaseDriver.GetString("Path"),
                                     DatabaseDriver.GetString("Message"));
                }
            }
            s.WriteLine(rf.GetHeaderText());
            s.WriteLine(rf.GetSeparatorText());
            for (int i = 0; i < rf.GetRowCount(); i++)
            {
                s.WriteLine(rf.GetDataText(i));
            }
            s.WriteLine();
            ReportMessages(ds, s, "DatabaseDriver", -1);  // returns a blank line at the end ... -1 = messages for all rows

            s.WriteLine("Other OLE DB Providers and ODBC Drivers:");
            s.WriteLine();
            rf.SetColumnNames("Name:L", "Type:L", "Version:L", "GUID:L", "Path:L", "Message:L");
            foreach (DataRow DatabaseDriver in dtDatabaseDriver.Rows)
            {
                if (DatabaseDriver.GetString("Supported") == "")  // only SQL drivers and providers have this set
                {
                    rf.SetcolumnData(DatabaseDriver.GetString("DriverName"),
                                 DatabaseDriver.GetString("DriverType"),
                                 DatabaseDriver.GetString("Version"),
                                 DatabaseDriver.GetString("Guid"),
                                 DatabaseDriver.GetString("Path"),
                                 DatabaseDriver.GetString("Message"));
                }
            }
            s.WriteLine(rf.GetHeaderText());
            s.WriteLine(rf.GetSeparatorText());
            for (int i = 0; i < rf.GetRowCount(); i++)
            {
                s.WriteLine(rf.GetDataText(i));
            }
            s.WriteLine();

            //
            // Process Drivers
            //
            // A list of all the database drivers in each process that has them loaded
            // The bulk are SQL drivers and some non-SQL drivers are also displayed, as well as if MSDADIAG.DLL has been loaded
            //

            s.WriteLine("Processes that have SQL Server (and some other) Drivers Loaded:");
            s.WriteLine();

            DataTable dtProcessDrivers = ds.Tables["ProcessDrivers"];
            rf = new ReportFormatter();

            rf.SetColumnNames("Process Name:L", "Process ID:R", "Drivers Loaded:L");
            foreach (DataRow ProcessDrivers in dtProcessDrivers.Select("", "ProcessName"))
            {
                rf.SetcolumnData(ProcessDrivers.GetString("ProcessName"),
                                    ProcessDrivers.GetString("ProcessID"),
                                    ProcessDrivers.GetString("DriverList"));
            }
            s.WriteLine(rf.GetHeaderText());
            s.WriteLine(rf.GetSeparatorText());
            for (int i = 0; i < rf.GetRowCount(); i++)
            {
                s.WriteLine(rf.GetDataText(i));
            }
            s.WriteLine();
            ReportMessages(ds, s, "ProcessDrivers", -1);  // returns a blank line at the end ... -1 = messages for all rows

            //
            // SQL Aliases
            //

            DataTable dtSQLAlias = ds.Tables["SQLAlias"];
            if (dtSQLAlias.Rows.Count == 0)
            {
                s.WriteLine("No SQL Aliases were found on this machine.");
            }
            else
            {
                s.WriteLine("SQL Aliases:");
                s.WriteLine();
                rf = new ReportFormatter();
                rf.SetColumnNames("Alias Name:L", "Protocol:L", "Server Name:L", "Port:R", "32-bit:R");
                foreach (DataRow SQLAlias in dtSQLAlias.Select("", "AliasName"))
                {
                    rf.SetcolumnData(SQLAlias.GetString("AliasName"),
                                     SQLAlias.GetString("Protocol"),
                                     SQLAlias.GetString("ServerName"),
                                     SQLAlias.GetString("Port"),
                                     SQLAlias.GetBoolean("64Bit") == true ? "" : "Yes");  // backward logic due to column name
                }
                s.WriteLine(rf.GetHeaderText());
                s.WriteLine(rf.GetSeparatorText());
                for (int i = 0; i < rf.GetRowCount(); i++)
                {
                    s.WriteLine(rf.GetDataText(i));
                }
            }
            s.WriteLine();
            ReportMessages(ds, s, "SQLAlias", -1);  // -1 = All messages for this table; returns a blank line at the end

            //
            // SQL Client Driver Settings
            //

            DataTable dtClientSNI = ds.Tables["ClientSNI"];
            if (dtClientSNI.Rows.Count == 0)
            {
                s.WriteLine("No SQL Client Driver SNI settings were found.");
            }
            else
            {
                s.WriteLine("SQL Client Driver SNI Settings:");
                s.WriteLine();
                rf = new ReportFormatter();
                rf.SetColumnNames("Client Name:L", "Protocol Order:L", "Force Encryption:R", "Trust Server Cert:R", "TCP Default Port:R", "Keep-Alive Interval (ms):R", "Keep-Alive Retry Interval (ms):R", "32-bit:R");
                foreach (DataRow ClientSNI in dtClientSNI.Rows)
                {
                    rf.SetcolumnData(ClientSNI.GetString("Name"),
                                     ClientSNI.GetString("ProtocolOrder"),
                                     ClientSNI.GetBoolean("ForceEncryption") == true ? "Yes" : "",
                                     ClientSNI.GetBoolean("TrustServerCertificate") == true ? "Yes" : "",
                                     ClientSNI.GetString("TcpDefaultPort").ToString(),
                                     ClientSNI.GetString("TcpKeepAliveInterval").ToString(),
                                     ClientSNI.GetString("TcpKeepAliveRetryInterval").ToString(),
                                     ClientSNI.GetBoolean("64Bit") == true ? "" : "Yes");  // backward logic due to column name
                }
                s.WriteLine(rf.GetHeaderText());
                s.WriteLine(rf.GetSeparatorText());
                for (int i = 0; i < rf.GetRowCount(); i++)
                {
                    s.WriteLine(rf.GetDataText(i));
                }
            }
            s.WriteLine();
            ReportMessages(ds, s, "ClientSNI", -1);  // -1 = All messages for this table; returns a blank line at the end
        }

        static void ReportSQLServer(DataSet ds, TextWriter s)  // outputs computer and domain information
        {
            DataTable dtSQLInstance = ds.Tables["SQLInstance"];
            DataTable dtSQLServer = ds.Tables["SQLServer"];
            DataTable dtSuggestedSPN = ds.Tables["SuggestedSPN"];
            string temp = "";

            if (dtSQLInstance.Rows.Count == 0)
            {
                s.WriteLine("No SQL Server instances appear to be on this machine.");
                s.WriteLine("Note: Only SQL 2008 and later are checked. There may be SQL 2000 instances.");
                s.WriteLine();
            }
            else
            {
                ReportFormatter rf = new ReportFormatter();
                s.WriteLine("SQL Server Instances:");
                s.WriteLine("Note: Only SQL 2008 and later are checked. There may be SQL 2000 instances.");
                s.WriteLine();
                rf.SetColumnNames("Service Type:L", "Instance Name:L", "32-bit:L");
                foreach (DataRow SQLInstance in dtSQLInstance.Select("", "InstanceType,InstanceName"))
                {
                    rf.SetcolumnData(SQLInstance.GetString("InstanceType"),
                                     SQLInstance.GetString("InstanceName"),
                                     SQLInstance.GetBoolean("Wow64Node").ToString());
                }
                s.WriteLine(rf.GetHeaderText());
                s.WriteLine(rf.GetSeparatorText());
                for (int i = 0; i < rf.GetRowCount(); i++)
                {
                    s.WriteLine(rf.GetDataText(i));
                }
                s.WriteLine();

                foreach (DataRow SQLServer in dtSQLServer.Select("", "InstanceName"))
                {
                    DataRow SQLInstance = dtSQLInstance.Rows[SQLServer.GetInteger("ParentID")];
                    s.WriteLine($"Details for SQL Server Instance: {SQLServer.GetString("InstanceName")} ({SQLServer.GetString("Edition")})");
                    s.WriteLine();
                    s.WriteLine($"Version:                    {SQLServer.GetString("Version")} SP {SQLServer.GetString("ServicePack")} Patch Level: {SQLServer.GetString("PatchLevel")}");
                    s.WriteLine($"Clustered:                  {SQLServer.GetBoolean("clustered")}");
                    
                    bool alwaysOn = SQLServer.GetBoolean("AlwaysOn");
                    s.WriteLine($"Always-On:                  {alwaysOn}");
                    if (alwaysOn)
                    {
                        s.WriteLine($"Always-On Servers:          {SQLServer.GetString("AlwaysOnServers")}");
                        s.WriteLine($"Always-On Listeners:        {SQLServer.GetString("Listeners")}");
                        s.WriteLine($"Availability Groups:        {SQLServer.GetString("AvailabilityGroups")}");
                        s.WriteLine($"Replication Ports:          {SQLServer.GetString("ReplicationPorts")}");
                    }

                    s.WriteLine($"Authentication Mode:        {SQLServer.GetString("AuthenticationMode")}");
                    s.WriteLine($"Certificate:                {SQLServer.GetString("Certificate")}");
                    s.WriteLine($"ForceEncryption:            {SQLServer.GetBoolean("ForceEncryption")}");
                    s.WriteLine($"Hidden Instance:            {SQLServer.GetBoolean("Hidden")}");

                    string exp = SQLServer.GetString("ExtendedProtection");
                    string extProt = exp == "Off" ? "Off" : $"On ({SQLServer.GetString("ExtProtSPNs")})";
                    s.WriteLine($"Extended Protection:        {extProt}");

                    s.WriteLine($"Shared Memory Enabled:      {SQLServer.GetBoolean("SharedMemoryEnabled")}");

                    temp = SQLServer.GetBoolean("PipesEnabled") ? $" ({SQLServer.GetString("PipeName")})" : "";
                    s.WriteLine($"Named Pipes Enabled:        {SQLServer.GetBoolean("PipesEnabled")}{temp}");  // temp has a leading space if not empty

                    s.WriteLine($"TCP Enabled:                {SQLServer.GetBoolean("TCPEnabled")}");
                    if (SQLServer.GetBoolean("TCPEnabled") == true)
                    {
                        s.WriteLine($"Listen on all IPs:          {SQLServer.GetBoolean("ListenOnAllIPs")}");
                        s.WriteLine($"Keep-Alive Interval (ms):   {SQLServer.GetString("KeepAliveInterval")}");
                        s.WriteLine($"TCP Port(s):                {SQLServer.GetString("TCPPort")}");
                        s.WriteLine($"Dynamic TCP Port(s):        {SQLServer.GetString("TCPDynamicPort")}");
                    }

                    s.WriteLine($"Install Path:               {SQLServer.GetString("Path")}");
                    s.WriteLine($"ERRORLOG Path:              {SQLServer.GetString("ErrorLogPath")}");
                    s.WriteLine($"Current Process ID:         {SQLServer.GetString("ProcessID")}");
                    s.WriteLine($"Service Account:            {SQLServer.GetString("ServiceAccount")}");
                    s.WriteLine($"SPN Account:                {SQLServer.GetString("SPNServiceAccount")}");
                    s.WriteLine();

                    //
                    // For readability of the recommended SPNs, group the ones that exist first and the ones that don't exist last
                    // to avoid True/False/False/True in the Exists column.
                    //
                    // Sort order: Exists DESC => true (1) to come first and false (0) to come last
                    //

                    DataRow[] rows = dtSuggestedSPN.Select($"ParentID={SQLServer.GetInteger("ID")}", "Exists DESC");  

                    if (rows.Length > 0)
                    {
                        rf = new ReportFormatter();
                        rf.SetColumnNames("Suggested SPN:L", "Exists:L", "Status:L");
                        foreach (DataRow SPN in rows)
                        {
                            rf.SetcolumnData(SPN.GetString("SPNName"),
                                             SPN.GetBoolean("Exists").ToString(),
                                             SPN.GetString("Message"));
                        }
                        s.WriteLine(rf.GetHeaderText());
                        s.WriteLine(rf.GetSeparatorText());
                        for (int i = 0; i < rf.GetRowCount(); i++)
                        {
                            s.WriteLine(rf.GetDataText(i));
                        }
                        s.WriteLine();
                    }

                    // report messages in standard format
                    ReportMessages(ds, s, "SQLServer", SQLServer.GetInteger("ID"));  // returns a blank line at the end
                }
            }
        }

        static void ReportMessages(DataSet ds, TextWriter s, string tableName, int tableRow, bool blankLineAlways = false, bool WarningsAndAbove = false)
        {

            //
            // Outputs messages in descending order of severity, with a line break when the severity level changes.
            //

            bool messagesOutput = false;

            DataView dv = null;
            if (tableRow == -1)  // Messages for all rows
            {
                dv = new DataView(ds.Tables["Message"], $"TableName='{tableName}'", "Severity desc, Message asc", DataViewRowState.CurrentRows);
            }
            else
            {
                dv = new DataView(ds.Tables["Message"], $"TableName='{tableName}' AND TableRow={tableRow}", "Severity desc, Message asc", DataViewRowState.CurrentRows);
            }
            
            if (dv.Count == 0)
            {
                if (blankLineAlways) s.WriteLine();
                return;
            }

            Storage.SeverityLevel lastSev = (Storage.SeverityLevel)dv[0]["Severity"].ToInt();

            foreach (DataRowView drv in dv)
            {
                Storage.SeverityLevel sev = (Storage.SeverityLevel)drv["Severity"].ToInt();
                if (sev != lastSev && tableRow != -1)  // change in level - but only if not doing all rows at the same time
                {
                    lastSev = sev;
                    s.WriteLine();         // line break when changing severity levels
                }
                
                switch (sev)
                {
                    case Storage.SeverityLevel.Heading:
                        if (!WarningsAndAbove)
                        {
                            s.WriteLine($"{drv["Message"]}");
                            messagesOutput = true;
                        }
                        break;
                    case Storage.SeverityLevel.Exception:
                        string src = drv["exSource"].ToString();
                        if (src != "") src = "Source: " + src;
                        s.WriteLine($"{sev.ToString()}: {drv["Message"].ToString()}");
                        s.WriteLine($"Exception Type: {drv["ExceptionTypeName"].ToString()}     {src}");
                        s.WriteLine($"{drv["exMessage"].ToString()}");
                        s.WriteLine($"{drv["exStackTrace"].ToString()}");
                        messagesOutput = true;
                        break;
                    default:
                        if (!WarningsAndAbove && sev > Storage.SeverityLevel.Info)
                        {
                            s.WriteLine($"{sev.ToString()}: {drv["Message"].ToString()}");
                            messagesOutput = true;
                        }
                        break;
                }
            }
            if (messagesOutput) s.WriteLine(); // no extra blank lines if no messages were output
        }
    }
}
